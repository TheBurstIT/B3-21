# Калькулятор B3-21

## Введение

В проекте лежит руководство пользователя данного калькулятора (`manual.pdf`). Оно будет вам полезно для изучения принципа
работы калькулятора. Также оно включает в себя коды операций.

### Список группы

1. Глеб;
2. Ахмет;
3. Вальтер;
4. Аян;
5. Шоислом.

### Декомпозиция на подзадачи

* Реализация интерфейса (1):
    * Отображение данных (1а);
    * Разметка (1b);
    * Обработка запросов (1с);
* Классы:
    * class Calc (2):
        * Реализация (2а);
        * Реализация функций, отвечающих за элементарные операции (2b);
    * class Program (3);
    * class Buffer (4);
    * class Number (5);
* Backup (6);
* Написание документации (7).

### Распределение задач

| Участники | Задачи      |
|-----------|-------------|
| Глеб      | 2а, 3, 5, 7 |
| Ахмет     | 1a, 1c      |
| Вальтер   | 2b          |
| Аян       | 4,  6       |
| Шоислом   | 1b          |

## Описание калькулятора

### Устройство памяти

> У калькулятора есть буфер, в котором хранятся числа, а также
буфер, в котором хранится программа.

#### буфер для хранения чисел (class Buffer)
* Состоит из:
  * Нумерованные регистры
    * Состоит из девяти регистров (от 0 до 8); (уточнить)
    * Нулевой регистр называют х(0), первый - y(1);
    * x(0) отображается на экране калькулятора;
    * Калькулятор может обратиться к ненулевому регистру только для копирования
      туда значения из нулевого регистра, либо наоборот;
  * Кольцевой буфер
    * Содержит шесть узлов без учёта х(0); (уточнить)
    * Элемент, стоящий на нулевой позиции - х(0);
    * Калькулятор может обращаться только к х(0), а также вращать буфер на
      единицу.

####  буфер для хранения программы
* Содержит 60 команд;
* Калькулятор может обращаться к ячейке, соответствующей значению переменной `uint8_t CP::Program::step_`
* Калькулятор может изменять переменную `step_` на единицу, либо приравнивать её к нулю.

### Общие требования к реализации
* Исключения:
  * Если метод/функция не помечена `noexcept`, то она может выбросить исключение (все возможные исключения (будут) прописаны
    в документации, кроме критических неисправляемых исключений);
  * Если вызванный метод/функция выбросил исключение, а ваш метод/функция не может обработать исключение таким образом,
    чтобы это исключение не оказало некорректного влияния на работу калькулятора в дальнейшем, вы должны пробросить это
    исключение выше;
* Реализация методов класса должна происходить в файлах с расширением `.cpp` и соответствующим названием.

## Сущности проекта

### class Calc (в разработке)

### class Buffer
#### Требования к реализации
1. См. `буфер для хранения чисел (class Buffer)`;
2. Класс должен быть написан таким образом, что при изменении констант размера буфер продолжал бы работать корректно,
   имея другой размер;
3. Описание методов:
   1. Конструктор по умолчанию заполняет все элементы буфера объектами по умолчанию;
   2. Метод `std::vector<Number> GetNumeratedBuffer()` возвращает все элементы нумерованного буфера, включая х(0);
   3. Метод `std::vector<Number> GetRoundedBuffer()` возвращает все элементы кольцевого буфера без х(0) таким образом, что ближайший правый
      элемент относительно х(0) является первым элементов вектора, а ближайший левый - последним;
   4. Метод `void RoundBuffer(Round)` вращает кольцевой буфер на 1 в сторону, соответствующую одному из значений `enum Round`;
   5. Метод `void PutFromZToX(uint8_t)` копирует в х(0) значение элемента, имеющего индекс, равный принимаемому аргументу.
      В случае, если аргумент превышает индекс последнего элемента, метод выбрасывает исключение `std::out_of_range`;
   6. Метод `void PutFromXToZ(uint8_t)` копирует в элемент, имеющий индекс, равный принимаемому аргументу, значение х(0).
      В случае, если аргумент превышает индекс последнего элемента, метод выбрасывает исключение `std::out_of_range`;
   7. Метод `Number& GetX0()` возвращает ссылку на х(0);
   8. Метод `Buffer(const std::vector<Number>& numerated_buffer, const std::vector<Number>& rounded_buffer);` принимает для построения
      векторы, соответствующие возвращаемым векторам методами 2, 3.

### class Program (в разработке)
#### Описание
Калькулятор хранит программу в объекте этого класса.

#### Требования к реализации

### class Number (в разработке)
#### Описание
Калькулятор хранит объекты этого класса в буфере.

#### Требования к реализации

### Элементарные операции
#### Описание
Калькулятор производит нижеперечисленные операции только посредством вызова соответствующих функций.
Объявленные функции можно найти в файле `CalcExec/calc_exec.hpp`.
Название функции соответствует элементарной операции.

#### Перечень функций
0. `void Neutral()`


3. `void PArrowUp()`


6. `void ArrowUp()`


13. `void PXArrowY()`


16. `void XArrowY()`


23. `void PMultiply()`


26. `void Multiply()`


33. `void PDivision()`


36. `void Division()`


38. `void XExpY()`


45. `void FComma()`


46. `void Comma()`


48. `void BO()`


55. `void FPrefixMinus()`


56. `void PrefixMinus()`


65. `void FVP()`


66. `void VP()`


76. `void Cx()`

78. `void CP()`

83. `void PMinus()`


86. `void Minus()`


93. `void PPlus()`


96. `void Plus()`

#### Требования к реализации
1. Функция `Neutral` только приравнивает переменную `curr_func_button` к `ButNull`;
2. После выполнения функции, калькулятор должен находится в состоянии, соответствующему состоянию после выполнения данной элементарной операции
(достаточно после проведения работы, соответствующей названию функции приравнять переменную `curr_func_button` к `ButNull`);
3. Реализация функций должна производиться в файле `CalcExec/calc_operations.cpp`;
4. Если функция как-либо изменила состояние калькулятора, она должна вызвать метод `Calc::SendUpdateSignal()`.

### BackUp
#### Описание
Сохраняет состояние калькулятора / восстанавливает калькулятор.

#### Требования к реализации
1. Перед восстановлением калькулятора функция должна проверять данные на корректность (отсутствие постороннего вмешательства);
2. Класс `Calc`:
   1. Восстановление калькулятора происходит посредством вызова специального конструктора класса `Calc` - `Calc(const CP::Program& program_buffer, const CM::Buffer& register_buffer,
      Button curr_func_button, Mode mode);`;
   2. Данные, которые необходимо сохранить, получаются вызовом соответствующих методов `Calc` (упомянутый в пункте 2.i. конструктор
      принимает данные, которые необходимо сохранить при создании резервной копии).
3. Класс `Buffer`:
   1. Восстановление объекта класса происходит посредством вызова специального конструктора класса `Buffer` - `Buffer(const std::vector<Number>& numerated_buffer,
      const std::vector<Number>& rounded_buffer)`;
   2. Данные, которые необходимо сохранить, получаются вызовом соответствующих методов `Buffer` (упомянутый в пункте 3.i. конструктор
      принимает данные, которые необходимо сохранить при создании резервной копии).
4. Класс `Program`:
   1. Восстановление объекта класса происходит посредством вызова специального конструктора класса `Program` - `Program(const std::vector<OperationCodes>& data, uint8_t step)`;
   2. Данные, которые необходимо сохранить, получаются вызовом соответствующих методов `Program` (упомянутый в пункте 4.i. конструктор
      принимает данные, которые необходимо сохранить при создании резервной копии).
5. Класс `Number`:
   1. Восстановление объекта класса происходит посредством вызова специального конструктора класса `Number` -
      `Number(uint8_t characteristic, uint8_t mantissa, bool sign)`;
   2. Данные, которые необходимо сохранить, получаются вызовом метода `Trio<uint8_t, uint8_t, bool> GetClass()` (порядок
      данных соответствует их порядку в соответствующем конструкторе).
6. Если обнаружена некорректность принятых данных, функция выбрасывает исключение `std::invalid_argument`.

## Взаимодействие frontend'а c backend'ом

Всё взаимодействие, за исключением, возможно, визуализации, происходит с помощью методов `class CE::Calc`.

### Визуализация

* Для общения с процессом визуализации `class CE::Calc` использует очереди сообщений;
* Процесс визуализации может получить очередь сообщений с помощью метода `MQ::MessageQueue CE::Calc::GetDataUpdateMarker()`;
* `class CE::Calc` отправляет сообщения формата `enum CE::MessageToVisualize` типа `1`:
  * `UpdateData` требует обновить данные,
  * `Error` сообщает о некритической ошибке в процессе работы,
  * `GoodBie` сообщает о завершении жизни объекта `class CE::Calc`.


